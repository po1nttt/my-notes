
# ECDSA

标准的 ECDSA 签名过程中，每一个签名都必须使用一个**强随机且保密**的随机数 k。但在本题的 `task.py` 中，生成 k 的逻辑是硬编码的：`seed = sha512(b"bias" + bytes([i])).digest()`。

在调用 `sk.sign(msg, k=k)` 时，由于没有显式指定 `hashfunc`，`python-ecdsa` 库会根据其内部逻辑，对 `NIST521p` 曲线默认使用 SHA-1。


$$s \equiv k^{-1}(z + r \cdot d) \pmod n$$

其中 $n$ 是曲线的阶，$s$ 和 $r$ 是已知的签名对 1，$z$ 是消息哈希，$k$ 是我们算出的随机数。唯一未知的只有私钥 $d$。我们将公式进行变形：
 两边同乘 $k$：$s \cdot k \equiv z + r \cdot d \pmod n$

 移项：$r \cdot d \equiv s \cdot k - z \pmod n$

两边同乘 $r$ 的模逆 $r^{-1}$：**$d \equiv r^{-1}(s \cdot k - z) \pmod n$**

从 `signatures.txt` 中提取第一个签名的 $r$ 和 $s$ 2。
利用硬编码的 "bias" 算出该签名对应的 $k$。
使用 SHA-1 算法计算消息 `message-0` 的哈希值 $z$。
代入上述变形公式，直接算出私钥 $d$。
根据题目要求，将私钥 $d$ 转为十进制字符串，计算其 MD5 值得到最终 Flag。

```python

import hashlib  
import binascii  
from ecdsa import NIST521p  
  
n = NIST521p.order  
msg_bytes = b"message-" + bytes([0])  

sig_hex = "01a76ff5e0a4490f314ab2a0650d4e9d6955fb154c39eeec2700fefac7b4aeef1230142b1466809d30bc61f32d9ce44757b604b09e211753032c28b64ef9327db44d00c9545bcb3def28828a7424c03d5b688b7ea0581372d9efc417724ab6624244dae9283789a7d7a2f8c2f820fc032dec0c3c2363f2b759e81248f75110344cd13c26"  
  
   seed = hashlib.sha512(b"bias" + bytes([i])).digest()  
   return int.from_bytes(seed, "big")  
  
sig_bytes = binascii.unhexlify(sig_hex)  
mid = len(sig_bytes) // 2  
r = int.from_bytes(sig_bytes[:mid], "big")  
s = int.from_bytes(sig_bytes[mid:], "big")  
  

k = get_k(0)  
 
r_inv = pow(r, -1, n)  
d = (r_inv * (s * k - z)) % n  
   
print(f"flag{{{md5_val}}}")
```



## RSA_NestingDoll


看 `src.py` 中有生成外层素数 $p$ 的逻辑
先生成一个“光滑”数 $k$（代码中的 `p` 变量），它是由很多 20-bit 以下的小素数相乘得到的。
然后试图寻找 $p = k \cdot p_1 + 1$，使得 p 是个素数（其中 p1 是内层素数）。
所以
$$p - 1 = k \cdot p_1$$


k是一个光滑数，它的所有质因子都非常小（小于 $2^{20}$）。
 p1：是一个大素数（512 bit），它是 $n_1$ 的因子。

通常 RSA 的安全性基于 p 和 q 是随机的大素数。

如果 p1 只有小因子（即 p-1 是光滑的），我们可以直接用 Pollard's p1 算法 分解 n。
但因为p1 包含了一个巨大的因子 p1，所以传统的 Pollard's p-1 算法效率特别低

$$n_1 = p_1 \cdot q_1 \cdot r_1 \cdot s_1$$

这意味着，n1 是 p1 的倍数。
就可以知道 p1 中最难破解的那个大因子 p1

我们的目标是分解 n1，但为了做到这一点，我们采取“曲线救国”策略：先攻击 n，从中提取出 n1 的因子

用费马小定理

$$a^{p-1} \equiv 1 \pmod p$$

将指数 $p-1$ 拆开

$$a^{k \cdot p_1} \equiv 1 \pmod p$$


不知道 p1 是多少，但知道 n1 是 $p_1$ 的倍数。所以，如果我们将底数 $a$ 算 $n_1$ 次方：$a^{n_1}$，这就相当于指数里已经乘上了 $p_1$。
    
2. **搞定 $k$**：$k$ 是一些小素数的乘积。我们只需要把所有可能的小素数（20-bit 以下）统统乘到指数上去，就能覆盖掉 $k$。
    

当这两步都做完时，底数 $a$ 的指数就变成了 $n_1 \cdot (\text{很多小素数})$，这个指数一定是 $p_1 \cdot k$ 的倍数，也就是 $p-1$ 的倍数。

此时：

$$a^{\text{TotalExponent}} \equiv 1 \pmod p$$

这意味着 $a^{\text{TotalExponent}} - 1$ 是 $p$ 的倍数。

我们计算 $\text{GCD}(a^{\text{TotalExponent}} - 1, n)$，就能把 $p$ 抓出来。

---

### 第三层：脚本代码详细拆解

现在我们再看代码，每一行就都很清晰了。

#### 第一步：准备“子弹” (Sieve for small primes)

Python

```
# 题目中 smoothness=20，意味着 k 的因子最大是 2^20
# 我们生成 2^22 以内的素数，确保覆盖所有可能的因子
LIMIT = 1 << 22  
... # (这里是标准的素数筛选法，生成 primes 列表)
```

- **目的**：准备好所有可能构成 $k$ 的小因子。这些小因子稍后会乘到指数上去，用来“消掉” $p-1$ 结构中的 $k$ 部分。
    

#### 第二步：构造“特洛伊木马” (Initial Base)

Python

```
# Initial base: 2^(n1) mod n
a = pow(2, n1, current_n)
```

- **这是最关键的一行！**
    
- 通常 Pollard $p-1$ 算法从 $a=2$ 开始。
    
- 但这里我们从 $a = 2^{n_1} \pmod n$ 开始。
    
- **原理**：因为 $n_1$ 包含因子 $p_1$，所以现在的 $a$ 实际上已经是 $2^{p_1 \cdot (\dots)}$ 了。我们利用 $n_1$ 这个公开信息，瞬间跨越了分解 $p-1$ 中最大因子的难关。
    

#### 第三步：轰炸测试 (The Loop)

Python

```
for i, p_val in enumerate(primes):
    exponent_accum *= p_val # 把小素数累乘到指数里
    
    # 每积攒 500 个小素数，或者跑完最后的时候，进行一次计算
    if (i + 1) % batch_size == 0 or ...:
        a = pow(a, exponent_accum, current_n) # 更新底数 a
        exponent_accum = 1
        
        g = math.gcd(a - 1, current_n) # 检查是否已经变成了 1 mod p
```

- **逻辑**：
    
    - 我们在不断地给指数乘上小素数（$2, 3, 5, 7, \dots$）。
        
    - 随着循环进行，指数中积攒的因子越来越多。
        
    - 当某一个时刻，指数中积攒的小因子恰好包含了 $k$ 的所有因子时，配合之前已经乘进去的 $n_1$（包含 $p_1$），总指数就成为了 $p-1$ 的倍数。
        
    - 此时 `pow(a, ..., n)` 的结果模 $p$ 会变成 1。
        
    - `gcd(a-1, n)` 就会暴露出 $p$（或者 $q, r, s$ 中的某一个）。
        

#### 第四步：瓮中捉鳖 (Extract Inner Prime)

Python

```
if g > 1:
    # g 就是我们要找的外层因子 (比如 p)
    # 我们知道 p - 1 = k * p1
    # 所以 p1 一定是 p - 1 的因子
    # 同时 p1 也是 n1 的因子
    p_inner = math.gcd(g - 1, n1)
```

- **逻辑**：
    
    - 我们不仅要找外面的 $p$，我们的最终目标是里面的 $p_1$。
        
    - 利用题目给的数学关系：$p_1$ 既在 $p-1$ 里，也在 $n_1$ 里。
        
    - 两个大数的最大公约数，就是它们共同拥有的那个大因子 $p_1$。
        

#### 第五步：清理战场与解密

Python

```
    current_n //= g         # 把找到的因子从 n 里面除掉，避免重复找
    inner_factors.append(p_inner) # 保存找到的内层素数
```

- 当循环结束，`inner_factors` 列表中就会有 4 个素数：$p_1, q_1, r_1, s_1$。
    
- 有了这 4 个素数，我们就可以计算 $\phi(n_1)$，算出私钥 $d$，然后解密 Flag。
    

### 总结

这个脚本的“灵魂”在于利用 $n_1$ 作为指数初始值。

- **普通攻击**：试图分解 $n$ -> 很难。
    
- **本题攻击**：
    
    1. 我知道 $n$ 的弱点需要 $p_1$ 和 $k$ 配合才能攻破。
        
    2. $k$ 很小，我可以通过枚举（Sieve）搞定。
        
    3. $p_1$ 很大，但我可以直接用 $n_1$ 代替它（因为 $n_1$ 是 $p_1$ 的倍数）。
        
    4. 两者结合，直接用 Pollard's $p-1$ 算法秒杀 $n$，进而通过 GCD 还原出 $p_1$。
#### 第一步：生成小素数表 (Sieve)

脚本首先生成了 $2^{22}$ 以内的所有素数。这是为了覆盖 $k_p$ 中的所有小因子（题目中 smooth bound 是 20 bits）。

#### 第二步：构造初始底数 (The Magic Step)

这是解题的关键。脚本设置初始底数为：

Python

```
a = pow(2, n1, current_n)
```

数学意义：

$$a_{init} = 2^{n_1} \pmod n$$

因为 $n_1 = p_1 \cdot q_1 \cdot r_1 \cdot s_1$，所以指数 $n_1$ 包含了 $p_1$。

此时，$a_{init}$ 的指数中已经包含了 $p-1$ 结构中那个最大的困难部分（即 $p_1$）。

#### 第三步：执行 Pollard's $p-1$ 循环

接下来，脚本遍历生成的小素数表，将它们乘入指数中：

$$a \leftarrow a^{\text{small\_prime}} \pmod n$$

这个过程是为了覆盖 $k_p$ 部分的小因子。

当指数积累了足够多的小因子后，总指数 $E$ 将会是 $k_p \cdot p_1$ 的倍数，即 $p-1 \mid E$。

此时：

$$a \equiv 2^{E} \equiv 1 \pmod p$$

计算 $\text{gcd}(a-1, n)$ 就会暴露出 $n$ 的因子 $p$。

#### 第四步：提取内部素数 (Extract Inner Primes)

一旦我们通过 GCD 找到了外部模数的一个因子 $P_{outer}$（例如 $p$），我们需要还原出内部素数 $p_1$。

根据关系 $P_{outer} - 1 = k_p \cdot p_1$，我们知道 $p_1$ 是 $P_{outer}-1$ 的因子。

同时，$p_1$ 也是 $n_1$ 的因子。

所以：

$$p_{inner} = \text{gcd}(P_{outer} - 1, n_1)$$

脚本通过这个公式，逐个把 $p_1, q_1, r_1, s_1$ 全部找出来。

#### 第五步：解密 (Decryption)

集齐了 $n_1$ 的四个因子后，就是标准的多素数 RSA 解密：

1. 计算欧拉函数 $\phi(n_1) = (p_1-1)(q_1-1)(r_1-1)(s_1-1)$。
    
2. 计算私钥 $d = e^{-1} \pmod{\phi(n_1)}$。
    
3. 解密 $m = c^d \pmod{n_1}$。

```python
import math  
from Crypto.Util.number import long_to_bytes, inverse, isPrime  
  
n1 = 16141229822582999941795528434053604024130834376743380417543848154510567941426284503974843508505293632858944676904777719167211264225017879544879766461905421764911145115313698529148118556481569662427943129906246669392285465962009760415398277861235401144473728421924300182818519451863668543279964773812681294700932779276119980976088388578080667457572761731749115242478798767995746571783659904107470270861418250270529189065684265364754871076595202944616294213418165898411332609375456093386942710433731450591144173543437880652898520275020008888364820928962186107055633582315448537508963579549702813766809204496344017389879  
n = 484831124108275939341366810506193994531550055695853253298115538101629337644848848341479419438032232339003236906071864005366050185096955712484824249228197577223248353640366078747360090084446361275032026781246854700074896711976487694783856878403247312312487197243272330518861346981470353394149785086635163868023866817552387681890963052199983782800993485245670437818180617561464964987316161927118605512017355921555464359512280368738197370963036482455976503266489446554327046948670215814974461717020804892983665655107351050779151227099827044949961517305345415735355361979690945791766389892262659146088374064423340675969505766640604405056526597458482705651442368165084488267428304515239897907407899916127394598273176618290300112450670040922567688605072749116061905175316975711341960774150260004939250949738836358264952590189482518415728072191137713935386026127881564386427069721229262845412925923228235712893710368875996153516581760868562584742909664286792076869106489090142359608727406720798822550560161176676501888507397207863998129261472631954482761264406483807145805232317147769145985955267206369675711834485845321043623959730914679051434102698588945009836642922614296598336035078421463808774940679339890140690147375340294139027290793  
c = 657984921229942454933933403447729006306657607710326864301226455143743298424203173231485254106370042482797921667656700155904329772383820736458855765136793243316671212869426397954684784861721375098512569633961083815312918123032774700110069081262242921985864796328969423527821139281310369981972743866271594590344539579191695406770264993187783060116166611986577690957583312376226071223036478908520539670631359415937784254986105845218988574365136837803183282535335170744088822352494742132919629693849729766426397683869482842748401000853783134170305075124230522253670782186531697976487673160305610021244587265868919495629  
e = 65537  


LIMIT = 1 << 22  
primes = []  
is_prime = bytearray([1]) * LIMIT  
is_prime[0] = 0  
is_prime[1] = 0  
for i in range(2, LIMIT):  
    if is_prime[i]:  
        primes.append(i)  
        for j in range(i * i, LIMIT, i):  
            is_prime[j] = 0  
  


current_n = n  
inner_factors = []  
    
a = pow(2, n1, current_n)  
  
batch_size = 500  
exponent_accum = 1  
  
for i, p_val in enumerate(primes):  
    exponent_accum *= p_val  
  

    if (i + 1) % batch_size == 0 or i == len(primes) - 1:  
        a = pow(a, exponent_accum, current_n)  
        exponent_accum = 1  
  
        # Check GCD  
        g = math.gcd(a - 1, current_n)  
  
        if g > 1:  
        
            p_inner = math.gcd(g - 1, n1)  
  
            if p_inner > 1 and isPrime(p_inner):  
                if p_inner not in inner_factors:  
                    print(f"[+] Found inner prime: {p_inner}")  
                    inner_factors.append(p_inner)  
  
  
                    current_n //= g  
                    a = a % current_n    
  
                    if len(inner_factors) == 4:  
                        print("[*] All 4 inner primes found.")  
                        break  
            else:  
				pass
  
if len(inner_factors) != 4:  
    print("[-] Failed to find all primes. Try increasing sieve limit.")  
    exit()  
  

p1, q1, r1, s1 = inner_factors  
phi = (p1 - 1) * (q1 - 1) * (r1 - 1) * (s1 - 1)  
d = inverse(e, phi)  
m = pow(c, d, n1)  
  
flag_padded = long_to_bytes(m)  
print(f"Decrypted: {flag_padded}")  
  
try:  
    print(f"Flag: {flag_padded.split(b'}')[0].decode() + '}'}")  
except:  
    pass
```

#### 1. 核心挑战分析

- **防御机制**：目标银行使用 **Isolation Forest (孤立森林)**。这种算法通过随机切分空间来孤立点，正常数据通常聚集在高密度区域，而异常数据则容易在较少的切分步数内被孤立。
    
- **限制条件**：
    
    - **金额达标**：总额需 > $2,000,000。
        
    - **分布对齐**：伪造数据必须符合 20 维特征的原始分布规律。
        
    - **查重绕过**：禁止直接重放（Replay）原始数据，且伪造数据自身不能有大量重复。
        
    - **格式严格**：必须以 `EOF` 结尾，且包含表头。
        

#### 2. 技术路线：生成-判别对抗架构 (GAN-like Approach)

本脚本采用了类似对抗网络（GAN）的思路，但在黑盒环境下简化为两个步骤：

##### 第一步：分布拟合与逆向建模 (生成器角色)

- **算法选择**：使用 **Gaussian Mixture Model (GMM, 高斯混合模型)**。
    
- **原理**：GMM 能够通过学习原始 `public_ledger.csv` 的均值和协方差矩阵，拟合出 20 个特征之间的数学相关性。
    
- **绕过查重**：通过 `gmm.sample()` 进行概率采样，生成的每一个点在数学上处于“正常区域”，但在数值上是全新的随机浮点数，从而完美避开黑名单和去重检测。
    

##### 第二步：本地红队验证 (判别器角色)

- **算法选择**：本地部署同样的 **Isolation Forest**。
    
- **逻辑**：在提交给服务器之前，先过一遍“自己人”的审查。
    
- **防御加固**：设置 `contamination=0.01`。如果生成的数据连本地模型都判定为 `is_normal == 1`，那么骗过服务端相同算法模型的成功率极高。
    

#### 3. 脚本实现关键细节

- **特征工程**：将原始数据的列名（如 `f0`）映射为题目要求的标准格式 `feat_0...feat_19`。
    
- **数据清洗 (Sanity Check)**：
    
    - **黑名单检查**：使用 `set(tuple(x))` 存储原始数据，确保新生成的每一行都不在原始记录中。
        
    - **业务逻辑验证**：强制 `feat_0 > 0`，确保交易金额为正，符合现实逻辑。
        
- **随机性控制**：引入 `RANDOM_SEED`。这保证了实验的可重复性，同时也允许通过更换种子产生不同的攻击载荷（Payload）。
![[Pasted image 20251228182425.png]]


53-14删去


54-06有问题
39-02有问题