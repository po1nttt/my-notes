[我是如何利用环境变量注入执行任意命令 | 离别歌](https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html)


# Bash4.4以上
variables.c的`initialize_shell_variables`函数用于将环境变量注册成SHELL的变量，其中包含的一段代码引起了我的注意：
```c
for (string_index = 0; env && (string = env[string_index++]); ) { name = string; // ... 
if (privmode == 0 && read_but_dont_execute == 0 && STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) && STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) && STREQN ("() {", string, 4)) { 
size_t namelen; char *tname; /* desired imported function name */ 
namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN; 
tname = name + BASHFUNC_PREFLEN; /* start of func name */ 
tname[namelen] = '\0'; /* now tname == func name */ 
string_length = strlen (string); 
temp_string = (char *)xmalloc (namelen + string_length + 2); 
memcpy (temp_string, tname, namelen); 
temp_string[namelen] = ' '; 
memcpy (temp_string + namelen + 1, string, string_length + 1); /* Don't import function names that are invalid identifiers from the environment in posix mode, though we still allow them to be defined as shell variables. */ 
if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname))) parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD); 
else free (temp_string); /* parse_and_execute does this */ //... } }
```
这里for遍历了所有环境变量，并用`=`分割，`name`就是环境变量名，`string`是值。

当满足下面这些条件的情况下，`temp_string`将被传入`parse_and_execute`执行：

- `privmode == 0`，即不能传入`-p`参数
- `read_but_dont_execute == 0`，即不能传入`-n`参数
- `STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN)`，环境变量名前10个字符等于`BASH_FUNC_`
- `STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN)`，环境变量名后两个字符等于`%%`
- `STREQN ("() {", string, 4)`，环境变量的值前4个字符等于`() {`

前两个条件肯定是满足的，后三个条件是用户可控的，所以这个if语句是肯定可以进入的。进入if语句后，去除前缀`BASH_FUNC_`和后缀`%%`的部分将是一个变量名，而由`() {`开头的字符串将会被执行。

这里其实做的就是一件事：**根据环境变量的值初始化一个匿名函数，并赋予其名字**。

所以，我们传入下面这样一个环境变量，将会在Bash上下文中添加一个myfunc函数：

`env $'BASH_FUNC_myfunc%%=() { id; }' bash -c 'myfunc'`![[Pasted image 20251202215301.png]]
这里仍然存在一个问题是，因为在执行`parse_and_execute`的时候配置了`SEVAL_FUNCDEF`，我们只能利用这个方法定义函数，而无法逃逸出函数执行任意命令。解决这个问题的方法也很简单，我们只需要覆盖一些已有的“命令”，在后面执行这个命令的时候就可以执行到我们定义的函数里了。

那么，回到本文开头说的那个问题，我添加了一个名为`echo`的函数，这样在执行`echo hello`的时候实际上执行的是我添加的函数：

`env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello'`![[Pasted image 20251202215328.png]]
# Bash4.4以下
我本来以为这次的研究到头了，于是在还没有解决CentOS 7的问题时就把文章发了出来。

但我很快意识到我忽略了一个我很早就该注意到的问题——破壳漏洞（ShellShock）。我这次发现的这个POC和ShellShock的POC很相似，原因就是，这个`BASH_FUNC`的环境变量，就是因为修复ShellShock而引入的。

在ShellShock刚出现的时候，Bash的最新版本是4.3，这也是为什么Bash 4.4的时候引入了`BASH_FUNC`。但是，这不代表4.4以下的Bash就没有修复ShellShock漏洞，那么，他们是怎么修复的呢？

经过研究我发现，CentOS 7这类操作系统虽然修复了ShellShock漏洞，但是并不是通过升级Bash版本来修复的，而是通过“打补丁”。

我们来看看redhat对于Bash 4.2的补丁：[https://bugzilla-attachments.redhat.com/attachment.cgi?id=941826](https://bugzilla-attachments.redhat.com/attachment.cgi?id=941826)


```c
--- ../bash-4.2-orig/variables.c    2014-09-25 13:07:59.313209541 +0200 
+++ variables.c 2014-09-25 13:15:29.869420719 +0200 
@@ -268,7 +268,7 @@  
static void propagate_temp_var __P((PTR_T));  
static void dispose_temporary_env __P((sh_free_func_t *));       
-static inline char *mk_env_string __P((const char *, const char *)); 
+static inline char *mk_env_string __P((const char *, const char *, int));  
static char **make_env_array_from_var_list __P((SHELL_VAR **));  
static char **make_var_export_array __P((VAR_CONTEXT *));  
static char **make_func_export_array __P((void)); 
@@ -301,6 +301,14 @@  #endif  
}  
+/* Prefix and suffix for environment variable names which contain 
+   shell functions. */ 
  +#define FUNCDEF_PREFIX "BASH_FUNC_" 
  +#define FUNCDEF_PREFIX_LEN (strlen (FUNCDEF_PREFIX)) 
  +#define FUNCDEF_SUFFIX "()" 
  +#define FUNCDEF_SUFFIX_LEN (strlen (FUNCDEF_SUFFIX)) 
   + 
    +
```

可见，在这个补丁里也引入了`FUNCDEF_PREFIX`和`FUNCDEF_SUFFIX`，只不过和4.4以下的有一处差异：**Bash 4.4下`FUNCDEF_SUFFIX`等于`%%`，而这个4.2的补丁中`FUNCDEF_SUFFIX`等于`()`**。

这也我在CentOS 7下没有测试成功的原因，因为我设置的环境变量名不对。

所以，我修改了环境变量名重新测试，在CentOS 7下也能成功复现了
`env $'BASH_FUNC_echo()=() { id; }' bash -c "echo hello"`
![[Pasted image 20251202215707.png]]
所以，之后我们遇到环境变量注入，可以进行下列三种测试：

- Bash没有修复ShellShock漏洞：直接使用ShellShock的POC进行测试，例如`TEST=() { :; }; id;`
- Bash 4.4以前：`env $'BASH_FUNC_echo()=() { id; }' bash -c "echo hello"`
- Bash 4.4及以上：`env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello'`

在CentOS系系统下完美解决本文开头提到的问题，通杀所有Bash。

# 总结
文完整地讲述了我是如何研究环境变量注入导致的安全问题。

经过阅读dash和bash的代码，我发现了这样一些可以导致命令注入的环境变量：

- `BASH_ENV`：可以在`bash -c`的时候注入任意命令
- `ENV`：可以在`sh -i -c`的时候注入任意命令
- `PS1`：可以在`sh`或`bash`交互式环境下执行任意命令
- `PROMPT_COMMAND`：可以在`bash`交互式环境下执行任意命令
- `BASH_FUNC_xxx%%`：可以在`bash -c`或`sh -c`的时候执行任意命令

利用最后一个trick，我成功在CentOS下解决了本文开头提出的问题。